---
title: "Travaux Pratiques 2: Risk Management"
output:
#  bookdown::html_document2:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r include = FALSE}
# Setting global options for the document
knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(tidy.opts=list(width.cutoff=80),tidy=TRUE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(fig.align = "center")
```
# Just checking pushing and pulling in Git

# Loading the data
The file **Market.rda** contains the list **Market**.

The first element of the list **Market** is an xts object corresponding to the 
value of the SP500 index from "2000-01-03" until "2013-09-10".

The second element vix corresponds to the value of the VIX  index at the same 
dates.

The third element rf corresponds to the term structure on "2013-09-10" for 14
maturities varying from 1 day to 30 years.

The fourth (calls) and the fifth (puts) contains the strikes (K), 
maturities (tau) and implied volatilities (IV) for calls and puts options 
respectively.

We plot the volatility surface in Figure \ref{fig:surfvol}.


```{r surfvol, fig.cap ='\\label{fig:surfvol} Volatility surface for the put options in the list **Market**.' }
f_install_load_lib = function(x){
  
  # Function to load library x. It checks if library x is present in R.
  # If it is it loads it, otherwise it installs it then loads it.
  
  # x: string
  
  if(!require(x, character.only = TRUE)){ #Check if library x is loaded
    install.packages(x)
  }
  # load require package
  require(x, character.only = TRUE) 
}
lib_vec = c("xts", "rgl", "akima", "knitr")
invisible(lapply(lib_vec, f_install_load_lib)) # no output from lapply

# Load market data
load("Market.rda")

# Volatility surface
option_obs = Market[[5]]
strike_mkt = Market[[5]][ , 1]
tau_mkt =  Market[[5]][ , 2]
IV_mkt =  Market[[5]][ , 3]
vol_surf = interp(strike_mkt, tau_mkt, IV_mkt, xo = seq( min(strike_mkt),  
           max(strike_mkt), length.out = 250) , yo = seq( min(tau_mkt), 
           max(tau_mkt), length.out = 250) )

persp3d(vol_surf$x, vol_surf$y, vol_surf$z, aspect = c(1, 1, 0.5), 
        col = "white", xlab = "Strike (K)", ylab = "Maturity (tau)",
        zlab = "IV", polygon_offset = 1)
persp3d(vol_surf$x, vol_surf$y, vol_surf$z, front = "lines", back = "lines",
lit = FALSE, add = TRUE)
rglwidget()
```

# Pricing of a portfolio of options
```{r}
BS_price = function(S, K,  TT, vol, r, isCall){
  d1 = ( log(S/K) + (r + (vol ** 2)/2 ) * TT )/( vol * sqrt(TT))
  d2 = ( log(S/K) + (r - (vol ** 2)/2 ) * TT )/( vol * sqrt(TT))
  C = S  * pnorm(d1) - exp(-r * TT) * K * pnorm(d2)
  if(isCall){
    return(C)
  } else{
    return( exp(-r * TT) * K + C - S) # Put call parity
  }
}
S0 = as.numeric( tail(Market[[1]], n = 1) )
VIX = as.numeric( tail(Market[[2]], n = 1) )
# Preparing the vectors
S_vec = rep(S0, 4)
K_vec = c(1600, 1650, 1750, 1800)
TT_vec = c(20, 20, 40, 40)/250.0
vol_vec = rep(VIX, 4)
# interpolate rates (20 days and 40 days)
rates = Market[[3]]
# Use 7 days and 30 days to interpolate rates for 20 days
r20 = as.numeric(rates[2]) + ( 20 - 7)/(30 - 7) *
                 (as.numeric(rates[3]) - as.numeric(rates[2]) ) 
# Use 30 days and 90 days to interpolate rates for 40 days
r40 = as.numeric(rates[3]) + ( 40 - 30)/(90 - 30) *
                 (as.numeric(rates[4]) - as.numeric(rates[3]) ) 
r_vec = c(r20, r20, r40, r40)
isCall_vec = rep(TRUE, 4)
price_vec = mapply(BS_price, S_vec, K_vec, TT_vec, vol_vec, r_vec, isCall_vec)

V0 = sum(price_vec)
options_df = data.frame("S0" = S_vec, "K" = K_vec, "tau" = TT_vec, 
                        "sigma" = vol_vec, "r" = round(r_vec, 6), 
                        "C" = round(price_vec, 3))
```
The prices of the call options using the Black-Scholes formula are given in 
table \ref{tab: calls_prices)
```{r calls_prices, results = 'asis'}
knitr::kable(options_df, caption = "Call options prices")
```

The price of this book (the sum of prices of the calls that constitutes 
the book) is $V_0$ = `r round(V0, 2)`.

# One risk driver and Gaussian model

In this section, we assume that the risk of our book of options is driven by 
a single factor namely the change in price of the SP500 index.
The logreturns of the index are assumed to follow a normal distribution with 
parameters given by the mean and standard deviation from the historical values.

```{r PLdist_gauss1D, fig.cap = "\\label{fig:PLdist_gauss1D} P&L distribution for normal log returns of the SP500. The red line represents the value at risk at 95% probability.", fig.align = "center"}
set.seed(2019)
n_sim = 10000L
lib_vec = c("PerformanceAnalytics")
invisible(lapply(lib_vec, f_install_load_lib)) 
SP500_logrets = PerformanceAnalytics::Return.calculate(Market[[1]], method = "log") # log returns
SP500_logrets = SP500_logrets[-1] # Get rid of the first line
mu_SP500 = mean(SP500_logrets)
# Finding mean and variance
sigma2 = (length(SP500_logrets) - 1)/(length(SP500_logrets)) * var(SP500_logrets)
# Generate n_sim new stock prices scenario
gauss_rets_SP500 = rowSums(matrix(rnorm(5 * n_sim, mean = mu_SP500, sd = sqrt(sigma2)), nrow = n_sim, ncol = 5))
SP500_new = S0 * exp(gauss_rets_SP500)
# profit and loss distribution for 1 risk driver (1D)
BV_new = rep(NA, n_sim) # new book value

K_vec = c(1600, 1650, 1750, 1800)
vol_vec = rep(VIX, 4)
isCall_vec = rep(TRUE, 4)
TT_vec = c(15, 15, 35, 35)/250.0 # New maturities vector

# Use 1 day and 7 days to interpolate rates for 5 days
r5 = as.numeric(rates[1]) + ( 5 - 1)/(7 - 1) *
                 (as.numeric(rates[2]) - as.numeric(rates[1]) ) 
# Forward rates forward1 between (t1 = 5 days and t2 = 20 days) and
# forward2 between (t1 = 5 days and t2 = 40 days) assuming continuous 
# compounding r1,2 = (r2*t2 - r1*t1)/(t2 - t1)
forward1 = (20*r20 - 5*r5)/(20 -5)
forward2 = (40*r40 - 5*r5)/(40 -5)

r_vec = c(forward1, forward1, forward2, forward2)
for (i in 1:n_sim){
  S_vec = rep(as.numeric(SP500_new[i]), 4)
  price_vec = mapply(BS_price, S_vec, K_vec, TT_vec,
                     vol_vec, r_vec, isCall_vec)
  BV_new[i] = sum(price_vec)
}
PL_gauss1D = BV_new - V0
VaR95_gauss1D = quantile(PL_gauss1D, 0.05)
#ES95_gauss1D = ES( PL_gauss1D/1000, method = "historical", p = 0.95) * 1000
ES95_gauss1D = mean(PL_gauss1D[PL_gauss1D <= VaR95_gauss1D])

hist(PL_gauss1D, breaks = 10 * round(log(n_sim)))
abline(v = VaR95_gauss1D, col = "red", lwd = 2)
```

We model `r n_sim` possible values for the stocks in 5 days and 
use them to estimate the distribution for the P&L in a week (5 days).
The distribution of the P\&L is given in Figure \ref{fig:PLdist_gauss1D}.

The VaR at risk at the 95% confidence level is
VaR95 = `r round(abs(VaR95_gauss1D), 2)`
and the expected shortfall is ES95 = `r round( abs(ES95_gauss1D), 2)`.
So we expect the book of options to lose at least 
`r round(abs(VaR95_gauss1D), 2)` from its initial value 5% of the time.  

# Two risk drivers and Gaussian model

In this section, we assume that the risk of our book of options is driven by 
two factors namely the change in price of the SP500 index and the volatility 
of the market (given by the vix).
The logreturns of the SP500 and the vix are assumed to follow a normal distribution with parameters given by the mean and standard deviation from the historical 
values.

```{r PLdist_gauss2D, fig.cap = "\\label{fig:PLdist_gauss2D} P&L distribution for normal log returns of the SP500 and the vix. The red line represents the value at risk at 95% probability."}

set.seed(2019)
n_sim = 10000L
lib_vec = c("PerformanceAnalytics")
invisible(lapply(lib_vec, f_install_load_lib)) 
# log returns
SP500_logrets = PerformanceAnalytics::Return.calculate(Market[[1]], 
                                                       method = "log") 
SP500_logrets = SP500_logrets[-1] # Get rid of the first line
vix_logrets = PerformanceAnalytics::Return.calculate(Market[[2]], 
                                                       method = "log")
vix_logrets = vix_logrets[-1]
mu_SP500 = mean(SP500_logrets)
mu_vix = mean(vix_logrets)
# Finding mean and variance
sigma2 = ( length(SP500_logrets) - 1)/(length(SP500_logrets) ) * var(SP500_logrets)
sigma2_vix = ( length(vix_logrets) - 1)/(length(vix_logrets) ) * var(vix_logrets)
# Generate n_sim new stock prices scenario
gauss_rets_SP500 = rowSums( matrix(rnorm( 5 * n_sim, mean = mu_SP500, sd = sqrt(sigma2) ),
                            nrow = n_sim, ncol = 5) )
gauss_rets_vix = rowSums( matrix(rnorm( 5 * n_sim, mean = mu_vix, 
                                        sd = sqrt(sigma2_vix) ), 
                                 nrow = n_sim, ncol = 5) )
SP500_new = S0 * exp(gauss_rets_SP500)
vix_new = VIX * exp(gauss_rets_vix)

# profit and loss distribution for 1 risk driver (1D)
BV_new = rep(NA, n_sim) # new book value

K_vec = c(1600, 1650, 1750, 1800)
isCall_vec = rep(TRUE, 4)
TT_vec = c(15, 15, 35, 35)/250.0 # New maturities vector

# Use 1 day and 7 days to interpolate rates for 5 days
r5 = as.numeric(rates[1]) + ( 5 - 1)/(7 - 1) *
                 (as.numeric(rates[2]) - as.numeric(rates[1]) ) 
# Forward rates forward1 between (t1 = 5 days and t2 = 20 days) and
# forward2 between (t1 = 5 days and t2 = 40 days) assuming continuous 
# compounding r1,2 = (r2*t2 - r1*t1)/(t2 - t1)
forward1 = (20*r20 - 5*r5)/(20 -5)
forward2 = (40*r40 - 5*r5)/(40 -5)

r_vec = c(forward1, forward1, forward2, forward2)
for (i in 1:n_sim){
  S_vec = rep(SP500_new[i], 4)
  vol_vec = rep(vix_new[i], 4)
  price_vec = mapply(BS_price, S_vec, K_vec, TT_vec,
                     vol_vec, r_vec, isCall_vec)
  BV_new[i] = sum(price_vec)
}
PL_gauss2D = BV_new - V0
VaR95_gauss2D = quantile(PL_gauss2D, 0.05)
ES95_gauss2D = mean(PL_gauss2D[PL_gauss2D <= VaR95_gauss2D])

hist(PL_gauss2D, breaks = 10 * round(log(n_sim)))
abline(v = VaR95_gauss2D, col = "red", lwd = 2)
```
We model `r n_sim` possible values for the SP500 and the vix in 5 days and 
use them to estimate the distribution for the P&L in a week (5 days).
The distribution of the P\&L is given in Figure \ref{fig:PLdist_gauss2D}.

The VaR at risk at the 95% confidence level is
VaR95 = `r round(abs(VaR95_gauss2D), 2)`
and the expected shortfall is ES95 = `r round( abs(ES95_gauss2D), 2)`.
So we expect the book of options to lose at least 
`r round(abs(VaR95_gauss2D), 2)` from its initial value 5% of the time.

The results don't differ much from the case where only the stock was considered 
to drive the risk of the book.


# Two risk drivers and copula-marginal model (Student-t and Gaussian copula)

In this section, we assume that the risk of our book of options is driven by 
two factors namely the change in price of the SP500 index and the volatility 
of the market (given by the vix).
The logreturns of the SP500 are assumed to follow a Student-t distribution with 
$\nu = 10$ degrees of freedom and the logreturns of the vix are assumed to
follow  a Student-t distribution with  $\nu = 5$ degrees of freedom.
A normal Copula is assumed to merge the marginals.

```{r PLdist_ststgauss2D, fig.cap = "\\label{fig:PLdist_ststgauss2D} P&L distribution for normal log returns of the SP500 and the vix. The red line represents the value at risk at 95% probability."}

set.seed(2019)
n_sim = 10000L
lib_vec = c("PerformanceAnalytics", "copula", "MASS", "fGarch")
invisible(lapply(lib_vec, f_install_load_lib)) 
# log returns
SP500_logrets = PerformanceAnalytics::Return.calculate(Market[[1]], 
                                                       method = "log") 
SP500_logrets = as.numeric( SP500_logrets[-1] ) # Get rid of the first line
vix_logrets = PerformanceAnalytics::Return.calculate(Market[[2]], 
                                                       method = "log")
vix_logrets = as.numeric( vix_logrets[-1] )
df_SP500 = 10L
df_vix = 5L

# Fit student-t distributions
fit_SP500 =  suppressWarnings( fitdistr(SP500_logrets, "t", df = df_SP500) )
fit_vix =  suppressWarnings( fitdistr(vix_logrets, "t", df = df_vix) )

# Finding location and scale parameters of student-t distribution
mu_SP500 = as.numeric(fit_SP500$estimate[1])
mu_vix = as.numeric(fit_vix$estimate[1])

scale_SP500 = as.numeric(fit_SP500$estimate[2])
scale_vix = as.numeric(fit_vix$estimate[2])

# Merging using a normal Copula

U_SP500 = pstd(SP500_logrets, mean = mu_SP500, sd = scale_SP500, nu = df_SP500)
U_vix = pstd(vix_logrets, mean = mu_vix, sd = scale_vix, nu = df_vix)
U = cbind(U_SP500, U_vix)

C = normalCopula(dim = 2)
fit = fitCopula(C, data = U, method = "ml")

# Generating 5 days returns with the required relationship
U_sim = rCopula(5 * n_sim, fit@copula)
logrets_SP500 = rowSums( matrix(qstd(U_sim[, 1], mean = mu_SP500, 
                                     sd = scale_SP500, nu = df_SP500),
                                nrow = n_sim, ncol = 5) )
logrets_vix  = rowSums( matrix(qstd(U_sim[, 2], mean = mu_vix, sd = scale_vix,
                            nu = df_vix), nrow = n_sim, ncol = 5) )


SP500_new = S0 * exp(logrets_SP500)
vix_new = VIX * exp(logrets_vix)

# profit and loss distribution for 1 risk driver (1D)
BV_new = rep(NA, n_sim) # new book value

K_vec = c(1600, 1650, 1750, 1800)
isCall_vec = rep(TRUE, 4)
TT_vec = c(15, 15, 35, 35)/250.0 # New maturities vector

# Use 1 day and 7 days to interpolate rates for 5 days
r5 = as.numeric(rates[1]) + ( 5 - 1)/(7 - 1) *
                 (as.numeric(rates[2]) - as.numeric(rates[1]) ) 
# Forward rates forward1 between (t1 = 5 days and t2 = 20 days) and
# forward2 between (t1 = 5 days and t2 = 40 days) assuming continuous 
# compounding r1,2 = (r2*t2 - r1*t1)/(t2 - t1)
forward1 = (20*r20 - 5*r5)/(20 -5)
forward2 = (40*r40 - 5*r5)/(40 -5)

r_vec = c(forward1, forward1, forward2, forward2)
for (i in 1:n_sim){
  S_vec = rep(SP500_new[i], 4)
  vol_vec = rep(vix_new[i], 4)
  price_vec = mapply(BS_price, S_vec, K_vec, TT_vec,
                     vol_vec, r_vec, isCall_vec)
  BV_new[i] = sum(price_vec)
}
PL_ststgauss2D = BV_new - V0
VaR95_ststgauss2D = quantile(PL_ststgauss2D, 0.05)
ES95_ststgauss2D = mean(PL_ststgauss2D[PL_ststgauss2D <= VaR95_ststgauss2D])

hist(PL_ststgauss2D, breaks = 10 * round(log(n_sim)))
abline(v = VaR95_ststgauss2D, col = "red", lwd = 2)
```
We model `r n_sim` possible values for the SP500 and the vix in 5 days and 
use them to estimate the distribution for the P&L in a week (5 days).
The distribution of the P\&L is given in Figure \ref{fig:PLdist_gauss2D}.

The VaR at risk at the 95% confidence level is
VaR95 = `r round(abs(VaR95_ststgauss2D), 2)`
and the expected shortfall is ES95 = `r round( abs(ES95_ststgauss2D), 2)`.
So we expect the book of options to lose at least 
`r round(abs(VaR95_ststgauss2D), 2)` from its initial value 5% of the time.


# Volatility surface

```{r }

set.seed(2019)
f_parametric_IV = function(params, m, tau){
  alpha1 = params[1]
  alpha2 = params[2]
  alpha3 = params[3]
  alpha4 = params[4]
  
  stopifnot(length(m)==length(tau)) #Check moneyness and tau have same length
  sigma = alpha1 + alpha2 * ( m - 1)**2 + alpha3 * (m - 1)**3 +
          alpha4 * sqrt(tau)
  return(sigma)
}

f_obj_fn = function(params, options_data){
  m_vec = options_data[ , 1]
  tau_vec = options_data[ , 3]
  IV_vec = options_data[ , 4]
  sigma_model = f_parametric_IV(params, m_vec, tau_vec)
  return( sum( abs(sigma_model - IV_vec) ) )
}

S0 = as.numeric( tail(Market[[1]], n = 1) )
K_vec = c(1600, 1650, 1750, 1800)
TT_vec = c(15, 15, 35, 35)/250.0 # New maturities vector

calls_info = Market[[4]]
puts_info = Market[[5]]
options_all = rbind(calls_info, puts_info)
moneyness = options_all[ ,1]/S0
options_all = cbind(moneyness, options_all)

# Creating 5 days stock paths

# log returns
SP500_logrets = PerformanceAnalytics::Return.calculate(Market[[1]], 
                                                       method = "log") 
SP500_logrets = SP500_logrets[-1] # Get rid of the first line
vix_logrets = PerformanceAnalytics::Return.calculate(Market[[2]], 
                                                       method = "log")
vix_logrets = vix_logrets[-1]
mu_SP500 = mean(SP500_logrets)
mu_vix = mean(vix_logrets)
# Finding mean and variance
sigma2 = ( length(SP500_logrets) - 1)/(length(SP500_logrets) ) * var(SP500_logrets)
sigma2_vix = ( length(vix_logrets) - 1)/(length(vix_logrets) ) * var(vix_logrets)
# Generate n_sim new stock prices scenario
gauss_rets_SP500 = rowSums( matrix(rnorm( 5 * n_sim, mean = mu_SP500, sd = sqrt(sigma2) ),
                            nrow = n_sim, ncol = 5) )
gauss_rets_vix = rowSums( matrix(rnorm( 5 * n_sim, mean = mu_vix, 
                                        sd = sqrt(sigma2_vix) ), 
                                 nrow = n_sim, ncol = 5) )
SP500_new = S0 * exp(gauss_rets_SP500)
vix_new = VIX * exp(gauss_rets_vix)


# Replace strike by moneyness
params_vec = rep(0, 4)
obj_min = 1e6
n_repeat = 1000
for (i in 1:n_repeat){
  ini_params = runif(4, min = -5, max = 5)
  fit_params = optim(par = ini_params, f_obj_fn,
                   options_data = options_all)
  #params_vec = params_vec + fit_params$par
  if(fit_params$value < obj_min){
    obj_min = fit_params$value
    params_vec = fit_params$par
  }
}

#repricing the portfolio 

#  Shift parameter
delta_shift = params_vec[1] + params_vec[4] - VIX  


#  Volatility in 5 days
vix_shift = vix_new + delta_shift


# Use 1 day and 7 days to interpolate rates for 5 days
r5 = as.numeric(rates[1]) + ( 5 - 1)/(7 - 1) *
                 (as.numeric(rates[2]) - as.numeric(rates[1]) ) 
# Forward rates forward1 between (t1 = 5 days and t2 = 20 days) and
# forward2 between (t1 = 5 days and t2 = 40 days) assuming continuous 
# compounding r1,2 = (r2*t2 - r1*t1)/(t2 - t1)
forward1 = (20*r20 - 5*r5)/(20 -5)
forward2 = (40*r40 - 5*r5)/(40 -5)

# profit and loss distribution for 1 risk driver (1D)
BV_new = rep(NA, n_sim) # new book value

r_vec = c(forward1, forward1, forward2, forward2)
for (i in 1:n_sim){
  S_vec = rep(SP500_new[i], 4)
  vol_vec = rep(vix_shift[i], 4)
  price_vec = mapply(BS_price, S_vec, K_vec, TT_vec,
                     vol_vec, r_vec, isCall_vec)
  BV_new[i] = sum(price_vec)
}
PL_gauss_volsurf = BV_new - V0
VaR95_gauss_volsurf = quantile(PL_gauss_volsurf, 0.05)
ES95_gauss_volsurf = mean(PL_gauss_volsurf[PL_gauss_volsurf <= VaR95_gauss_volsurf])

hist(PL_gauss_volsurf, breaks = 10 * round(log(n_sim)))
abline(v = VaR95_gauss_volsurf, col = "red", lwd = 2)

```

We model `r n_sim` possible values for the SP500 and the vix in 5 days and 
use them to estimate the distribution for the P&L in a week (5 days).
The simulated values of the vix are then shifted by the difference between the
one year ATM value of the implied volatility and today value of the vix.
The distribution of the P\&L is given in Figure \ref{fig:PLdist_gauss_volsurf}.


The VaR at risk at the 95% confidence level is
VaR95 = `r round(abs(VaR95_gauss_volsurf), 2)`
and the expected shortfall is ES95 = `r round( abs(ES95_gauss_volsurf), 2)`.
So we expect the book of options to lose at least 
`r round(abs(VaR95_gauss_volsurf), 2)` from its initial value 5% of the time.


# Full approach

```{r}
set.seed(2019)
n_sim = 10000L
lib_vec = c("PerformanceAnalytics", "copula", "MASS", "fGarch", "rugarch")
invisible(lapply(lib_vec, f_install_load_lib)) 

# log returns
SP500_logrets = PerformanceAnalytics::Return.calculate(Market[[1]], 
                                                       method = "log") 
SP500_logrets = as.numeric( SP500_logrets[-1] ) # Get rid of the first line
mu_SP500 =  mean(SP500_logrets)

vix_logrets = PerformanceAnalytics::Return.calculate(Market[[2]], 
                                                       method = "log")
vix_logrets = as.numeric( vix_logrets[-1] )
mu_vix = mean(vix_logrets)

## Fit GARCH(1,1) to log returns of SP500
fit_GARCH_SP500.spec = ugarchspec(variance.model     = list(model = "sGARCH",
                                                 garchOrder = c(1, 1)), 
                       mean.model         = list(armaOrder = c(0, 0),
                                                 include.mean = TRUE), 
                       distribution.model = "norm")
fit_GARCH_SP500   =  ugarchfit(data = SP500_logrets, 
                               spec = fit_GARCH_SP500.spec)
mu_res_SP500 = mean(as.numeric(residuals(fit_GARCH_SP500)))
sd_res_SP500 = sd(as.numeric(residuals(fit_GARCH_SP500))) * 
                sqrt( (length(SP500_logrets) - 1) / length(SP500_logrets) )

# Fit AR(1) to log returns of Vix
fit_vix = arima(x = vix_logrets, order = c(1,0,0) )
mu_res_vix = mean(fit_vix$residuals)
sd_res_vix =  sqrt( (length(SP500_logrets) - 1) / length(SP500_logrets) ) * 
             sd(fit_vix$residuals)
 
 # Distribution of the marginals
U1 = pnorm(residuals(fit_GARCH_SP500), mean = mu_res_SP500, sd = sd_res_SP500)
U2 = pnorm(fit_vix$residuals , mean = mu_res_vix, sd = sd_res_vix)
U = cbind(U1, U2)

 # Fit normal copula
C = normalCopula(dim = 2)
fit = fitCopula(C, data = U, method = "ml")

 # Generate draws for the invariants
U_sim = rCopula( 5 * n_sim, fit@copula)
res_SP500 = qnorm(U_sim[ , 1],  mean = mu_res_SP500, sd = sd_res_SP500)
res_vix = qnorm(U_sim[ , 2],  mean = mu_res_vix, sd = sd_res_vix)
logrets_SP500 = rep( tail(SP500_logrets, 1), n_sim)
# Fitted conditional std
sigma2_SP500 = tail(fit_GARCH_SP500@fit$sigma, 1)^2 
logrets_vix = rep( tail(vix_logrets, 1), n_sim)
for(i in 1:5){
  #logrets_vix = mu_vix + as.numeric(fit_vix$coef[2]) +
  #  as.numeric(fit_vix$coef[1]) * (logrets_vix - mu_vix) +
  #  res_vix[( (i-1) * n_sim + 1 ) : (i * n_sim) ]
  
  logrets_vix = mu_vix + as.numeric(fit_vix$coef["intercept"]) +
    as.numeric(fit_vix$coef["ar1"]) * (logrets_vix - mu_vix) +
    res_vix[( (i-1) * n_sim + 1 ) : (i * n_sim) ]
  
  sigma2_SP500 = as.numeric( fit_GARCH_SP500@fit$coef["omega"] ) +
    as.numeric( fit_GARCH_SP500@fit$coef["alpha1"] ) * logrets_SP500^2 + 
    as.numeric(fit_GARCH_SP500@fit$coef["beta1"]) * sigma2_SP500
  
  #logrets_SP500 =  as.numeric( fit_GARCH_SP500@fit$coef["mu"] ) + 
  #  sigma2_SP500^0.5 * rnorm(n_sim) + 
  #  res_SP500[( (i-1) * n_sim + 1 ) : (i * n_sim) ]
  
  logrets_SP500 =  as.numeric( fit_GARCH_SP500@fit$coef["mu"] ) + 
    res_SP500[( (i-1) * n_sim + 1 ) : (i * n_sim) ]
}

SP500_new = S0 * exp(logrets_SP500)
vix_new = VIX * exp(logrets_vix)


# Use 1 day and 7 days to interpolate rates for 5 days
r5 = as.numeric(rates[1]) + ( 5 - 1)/(7 - 1) *
                 (as.numeric(rates[2]) - as.numeric(rates[1]) ) 
# Forward rates forward1 between (t1 = 5 days and t2 = 20 days) and
# forward2 between (t1 = 5 days and t2 = 40 days) assuming continuous 
# compounding r1,2 = (r2*t2 - r1*t1)/(t2 - t1)
forward1 = (20*r20 - 5*r5)/(20 -5)
forward2 = (40*r40 - 5*r5)/(40 -5)

# profit and loss distribution for 1 risk driver (1D)
BV_new = rep(NA, n_sim) # new book value

r_vec = c(forward1, forward1, forward2, forward2)
for (i in 1:n_sim){
  S_vec = rep(SP500_new[i], 4)
  vol_vec = rep(vix_new[i], 4)
  price_vec = mapply(BS_price, S_vec, K_vec, TT_vec,
                     vol_vec, r_vec, isCall_vec)
  BV_new[i] = sum(price_vec)
}
PL_full = BV_new - V0
VaR95_full = quantile(PL_full, 0.05)
ES95_full = mean(PL_full[PL_full <= VaR95_full])

hist(PL_full, breaks = 10 * round(log(n_sim)))
abline(v = VaR95_full, col = "red", lwd = 2)


```